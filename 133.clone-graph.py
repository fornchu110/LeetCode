#
# @lc app=leetcode id=133 lang=python3
#
# [133] Clone Graph
#

# @lc code=start
# ????linklist???????, ??node?????val?neighbor
# ??????????????linklist
# ?????deepcopy?, ??????
"""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
"""

# By DFS, time: O(n), space: O(n)
# ?DFS???, ??????hash?????????node
# ??DFS???
class Solution(object):
    def __init__(self):
        # ?hash??????node
        self.visited = {}

    def cloneGraph(self, node):
        """
        :type node: Node
        :rtype: Node
        """
        # ????
        if not node:
            return node
        
        # ??????
        if node in self.visited:
            # ???????node??clone node??
            return self.visited[node]

        # ????node??????node??????value
        clone_node = Node(val = node.val)
        # hash?node??key?????value????clone??
        self.visited[node] = clone_node

        # ???value, ??node?neighbors
        if node.neighbors:
            # ?neighbors???node?cloneGraph????
            clone_node.neighbors = [self.cloneGraph(n) for n in node.neighbors]
        
        # ?root??, ????????root?clone??????????
        return clone_node

# By BFS, time: O(n), space: O(n)
# BFS?????????, ???hash??????node
# class Solution(object):
#     def cloneGraph(self, node):
#         """
#         :type node: Node
#         :rtype: Node
#         """
#         if not node:
#             return node

#         visited = {}
#         queue = collections.deque([node])
#         # ????node?clone??????neighbors
#         visited[node] = Node(node.val, [])

#         # ?queue????????node?neighbors???
#         while queue:
#             tmp = queue.popleft()
#             for neighbor in tmp.neighbors:
#                 # ???????????queue??????neighbors
#                 if neighbor not in visited:
#                     visited[neighbor] = Node(neighbor.val, [])
#                     queue.append(neighbor)
#                 # ?clone??tmp?neighbors?????clone??neighbor
#                 visited[tmp].neighbors.append(visited[neighbor])
#         # node???, return clone??node
#         return visited[node]

# @lc code=end

