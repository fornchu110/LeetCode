#
# @lc app=leetcode id=371 lang=python3
#
# [371] Sum of Two Integers
# 給兩整數a、b, 用+和-以外的方式做出a+b
# 直觀想到bitwise運算, 觀察a+b的性質

# @lc code=start
# By bitwise, time: O(log(max_int)), space: O(1)
# 注意走訪一個數n所有bit的時間複雜度為log(n)
# 在二進位同一位數情況, a+b的結果其實等同XOR, 只是在1+1時要多處理一個進位
# Ex: 0+0=0, 0+1=1, 1+0=1, 1+1=0
# 那怎麼知道哪些位數要進位?觀察得知同位數下, AND後為1才會是要進位的數
# Ex: 0&0=0, 0&1=0, 1&0=0, 1&1=1
# 所以將a+b拆分為無進位的結果和有進位的結果

# 注意python的整數類型是無限制, 所以要做MASK的額外處理變回32bit時的樣子
# 變回32bits時的樣子代表有overflow就該overflow
# 對MASK1取mod只剩下不到2^32的數, 也就是都剩下尾32個bit
# c語言用unsigned int處理
MASK1 = 4294967296  # 2^32, 等同於0x100000000 (1 0000 0000 0000 0000 0000 0000 0000 0000)
MASK2 = 2147483648  # 2^31, 等同於0x80000000(1000 0000 0000 0000 0000 0000 0000 0000)
MASK3 = 2147483647  # 2^31-1, 等同於0x7FFFFFFF(0111 1111 1111 1111 1111 1111 1111 1111)

class Solution:
    def getSum(self, a: int, b: int) -> int:
        a %= MASK1
        b %= MASK1
        # Ex: a=5(0101), b=4(0100), 
        # 直到沒有進位要處理才代表上輪的a = a^b等同實際上的a+b
        while b!=0:
            # 需要先檢查那些位數要進位
            # a&b代表要進位的位, <<1後的carry就代表進位過後的結果
            # Ex: 第一輪a&b=0100, a&b<<1=1000
            # Ex: 第二輪a&b=1000&0001=0, carry=0, 所以在這輪就會結束
            carry = ((a&b)<<1)%MASK1
            # 把a處理成經過未進位加法後的樣子, 等同於做加法
            # Ex: 第一輪a^b=0001
            # EX: 第二輪a^b=0001^1000=1001, 也就是9, 用a儲存起來
            a = (a^b)%MASK1
            # b變成進位過後的結果部分
            # Ex: 第一輪b=1000
            # Ex: 第二輪b=carry=0, 即將結束迴圈
            b = carry
        # 所以結束迴圈後, 若a是正數那就是實際上的答案
        # 把結果換算回去python整數, input有負數所以結果也可能是負數
        # 有號32bit int是-2^31~2^31-1, 而2^31代表著第32個bit
        # 所以當和2^31做&非0時, 代表第32個bit為1, 也就是負數
        if a&MASK2:
            # 由於前面只取了負數的後32bit做運算, 要轉換回去
            # Ex: 假設8bit, 結果a=-4這時卻會得出0000 1100, 所以要轉換回1111 1100
            # a^MASK2^MASK3等同於a^0xFFFFFFFF, 也就是2^32-1
            # ~(a^0xFFFFFFFF)等同於先把32位內轉成補數, 再把整個int轉成補數
            # 最後32位內沒變, 但32位以外變成11..11, 才會變成正確負數
            return ~(a^MASK2^MASK3)
        # 正數, 直接return a
        else:
            return a
        
# @lc code=end

